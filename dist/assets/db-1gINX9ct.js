const u="perfect";function l(){return new Promise((n,r)=>{const t=indexedDB.open(u,1);t.onupgradeneeded=()=>{const e=t.result;if(!e.objectStoreNames.contains("notes")){const o=e.createObjectStore("notes",{keyPath:"id",autoIncrement:!0});o.createIndex("by_date","date"),o.createIndex("by_created","createdAt")}if(!e.objectStoreNames.contains("files")){const o=e.createObjectStore("files",{keyPath:"id",autoIncrement:!0});o.createIndex("by_date","date"),o.createIndex("by_created","createdAt"),o.createIndex("by_type","type")}},t.onsuccess=()=>n(t.result),t.onerror=()=>r(t.error)})}async function i(n,r,t){const e=await l();return new Promise((o,s)=>{const c=e.transaction(n,r),a=c.objectStore(n),d=t(a);c.oncomplete=()=>o(d),c.onerror=()=>s(c.error)})}async function y({file:n,date:r}){const t=Date.now(),{name:e,type:o,size:s}=n,a={name:e,type:o,size:s,date:r,createdAt:t,blob:n};return i("files","readwrite",d=>d.add(a))}async function b(){return i("files","readonly",n=>new Promise((r,t)=>{const e=n.getAll();e.onsuccess=()=>r(e.result),e.onerror=()=>t(e.error)}))}async function f(n){return i("files","readwrite",r=>r.delete(n))}function m(n=new Date){const r=new Date(n),t=`${r.getMonth()+1}`.padStart(2,"0"),e=`${r.getDate()}`.padStart(2,"0");return`${r.getFullYear()}-${t}-${e}`}export{y as a,f as d,b as g,m as y};
